#include "../sort.cpp"

//0.双向冒泡排序，即第一趟把关键字最大的元素放在序列的最后面，第二趟把关键字最小的元素放在序列的最前面，如此反复进行。

//1.设计把顺序表所有奇数移动到所有偶数前边的算法（要求时间最少，辅助空间最少）

//2.找到第k小的元素(类似快排)

//3.设有一个仅由红、白、蓝三种颜色的条块组成的条块序列，写一个时间复杂度为O(n)的算法，使得这些条块按红、白、蓝的顺序排好

//4.在基于单链表表示的待排序关键字序列上进行简单选择排序

//5.判断一个数据序列是否构成一个小根堆

//6.顺序表表中元素存储在数组下标[1,m+n]的范围 m 个元素递增有序，后 n 个元素递增有序，设计一个算法，使得整个顺序表有序

//7.数组中存放了一个无序序列K1~n,要求将Kn放在将元素排序后的正确位置上,比较次数尽可能小

/*真题1.已知由n （n>=2）个正整数构成的集合A= {ak | 0 <= k < n},将其划分为两个不相交的子集A1和A2,
元素个数分别是n1和n2，A1和A2中的元素之和分别S1和S2
设计一个尽可能高效的划分算法，满足|n1 - n2|最小且|S1 - S2|最大*/

//真题2.现有n(n> 100000)个数保存在一维数组M中，需要查找M中最小的10个数

//真题3.
void cmpCountSort(int a[], int b[], int n) {
    int i, j, * count;
    count = new int[n];
    for (i = 0;i < n;i++) count[i] = 0;
    for (i = 0;i < n - 1;i++)
        for (j = i + 1;j < n;j++)
            if (a[i] < a[j]) count[j]++;
            else count[i]++;
    for (i = 0;i < n;i++) b[count[i]] = a[i];
    delete count;
}
/*
a.int a[6] = {25,-10,25,10,11,19} ,b[6],调用 cmpCountSort (a,b, 6)后数组b中的内容是什么？
b.若a中含有n个元素，则算法执行过程中，元素之间的比较次数是多少？
c.算法稳定吗？若不是，修改为稳定算法
*/

int main() {
    int temp[8] = { 1,24,12,35,4,13,72,54 };
    print_arr(temp, 8);
    cout << "after sort:\n";
    print_arr(Insertsort(temp, 8), 8);
}